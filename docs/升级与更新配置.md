# 升级与更新配置说明

本项目支持两类升级：

- 热更新（仅更新前端渲染层静态资源，即 `dist/` 内容）
- 安装包升级（更新 Electron 主进程/预加载/依赖等，即更新整个 App）

## 1. 热更新（Renderer 热更新）

### 1.1 热更新是什么

热更新只替换 Renderer 资源包（通常是 Vite build 后的 `dist/`：`index.html` + `assets/`），不会替换 Electron 主进程代码、Native 依赖、驱动等。

适用场景：

- UI 文案/布局/交互逻辑更新
- 纯前端静态资源更新

不适用场景：

- 主进程逻辑变更（TCP/串口/DLL 等）
- 需要变更 Node/Electron 依赖、原生模块等
- 需要修改 preload 暴露 API

### 1.2 热更新的存储位置

热更新会落盘到：

- `app.getPath('userData')/renderer-updates/versions/<installId>/`
- 当前启用版本记录：`app.getPath('userData')/renderer-updates/active.json`

其中 `active.json` 由安装热更新成功后写入，示例：

```json
{
  "activeDirName": "v1700000000000",
  "rendererVersion": "1.0.1"
}
```

### 1.3 当前版本怎么定义（用于与服务器对比）

客户端会同时携带两个版本概念：

- `appVersion`：安装包版本（来自 `app.getVersion()`）
- `rendererVersion`：热更新版本
  - 优先取 `active.json.rendererVersion`
  - 没有热更新/未写入时，默认等于 `appVersion`

### 1.4 热更新包如何制作

1. 在项目根目录执行：

```bash
npm run build
```

2. 将 `dist/` 打包成 zip，zip 结构支持两种：

- 方式 A：zip 根目录直接包含 `index.html` 和 `assets/`
- 方式 B：zip 根目录包含一个目录（例如 `dist/`），目录内再包含 `index.html` 和 `assets/`

要求：

- 解压后必须能找到 `index.html`

### 1.5 启动时的版本检查与热更新流程

启动顺序：

1. 先加载 `splash.html`
2. splash 阶段发起版本检查请求（如果配置了版本检查地址）
3. 服务器如果返回热更新，则下载 zip → 校验可选 sha256 → 解压安装
4. 安装完成后再创建主窗口并加载 Renderer（此时会优先加载热更新后的 `index.html`）

### 1.6 服务器版本检查接口协议

客户端请求：

- 方法：GET
- URL：由配置提供（见下文配置章节）
- Query 参数：
  - `appVersion`
  - `rendererVersion`
  - `platform`（如 `win32`/`darwin`）
  - `arch`（如 `x64`/`arm64`）

服务端响应（JSON），支持三类：

1) 无更新：

```json
{ "updateType": "none" }
```

2) 热更新（Renderer zip）：

```json
{
  "updateType": "hot",
  "version": "1.0.1",
  "url": "https://example.com/renderer/1.0.1/renderer.zip",
  "sha256": "可选：zip 文件 sha256"
}
```

3) 安装包升级（仅提示/分流，具体升级逻辑见第 2 章）：

```json
{
  "updateType": "installer",
  "version": "1.0.2",
  "url": "可选：下载页/安装包地址"
}
```

建议服务端判断策略：

- 如果 `rendererVersion < latestHotVersion`：返回 `updateType: "hot"`
- 如果需要强制升级 App：返回 `updateType: "installer"`（并提供下载页）

### 1.7 如何回滚热更新

方式 A：删除目录回滚

- 删除 `app.getPath('userData')/renderer-updates/`
- 下次启动会回退加载安装包内置的 `dist/index.html`

方式 B：调用回滚 API（如果你有接 UI 按钮或调用接口）

- `window.electronAPI.revertRendererUpdate()`

## 2. 安装包升级（App 升级）

### 2.1 App 升级是什么

App 升级更新的是完整安装包（包含主进程、preload、依赖、原生模块等）。

项目内已经接入 `electron-updater`，并提供渲染进程触发检查更新：

- `window.electronAPI.checkUpdate()`

主进程实现位于：[update.ts](file:///Users/wanghu/work/study/test26/src/main/services/update.ts)

### 2.2 App 升级需要的发布配置（关键）

`electron-updater` 需要你在 `electron-builder` 配置里设置 `publish`（或其它 feed 配置），否则 `checkForUpdatesAndNotify()` 不知道去哪里拉取更新。

当前项目的打包配置文件是：[electron-builder.json5](file:///Users/wanghu/work/study/test26/electron-builder.json5)

常见做法是使用 generic provider（自建静态文件服务器/CDN）：

```json5
{
  // ...
  "publish": [
    {
      "provider": "generic",
      "url": "https://example.com/app-updates/"
    }
  ]
}
```

然后将 `electron-builder` 生成的更新文件（例如 `latest-mac.yml`、`latest.yml`、blockmap、dmg/nsis 安装包等）上传到该目录。

不同平台会生成不同的元数据文件：

- mac：`latest-mac.yml`
- win（nsis）：`latest.yml`

### 2.3 App 升级与热更新如何分工

推荐策略：

- UI 小改动优先走热更新（`updateType: "hot"`）
- 涉及主进程、驱动、preload API、原生模块变更走 App 升级（`updateType: "installer"`）

你可以让版本检查接口在发现必须 App 升级时返回 `installer`，并在 UI 里提示用户点击“检查更新/下载新安装包”。

## 3. 配置方式（服务器地址/超时）

### 3.1 配置文件（推荐）

启动阶段版本检查读取配置文件：

- `app.getPath('userData')/boot-config.json`

文件示例：

```json
{
  "versionCheckUrl": "https://example.com/check",
  "versionCheckTimeoutMs": 6000
}
```

字段说明：

- `versionCheckUrl`
  - 留空：禁用启动时版本检查
  - 非空：必须是 `http`/`https` URL
- `versionCheckTimeoutMs`
  - 默认 6000
  - 范围会被规范化到 1000–60000

首次运行时如果 `boot-config.json` 不存在，会从安装包内置默认模板生成：

- 模板文件：[boot-config.default.json](file:///Users/wanghu/work/study/test26/build/boot-config.default.json)

### 3.2 环境变量（临时覆盖）

环境变量优先级高于配置文件：

- `FWACS_VERSION_CHECK_URL=https://example.com/check`

适合开发、灰度或临时排查，不推荐作为长期配置方式（因为双击启动时环境变量不一定存在）。

### 3.3 右下角隐藏入口

应用右下角有一个不明显的齿轮按钮，用于快速修改版本检查地址，并提供“一键打开配置文件位置”。

## 4. 常见问题

### 4.1 为什么热更新不直接改安装目录文件

安装目录通常需要管理员权限，且容易被系统保护/签名校验影响；放在 `userData` 目录更稳，更适合运行时写入与回滚。

### 4.2 版本对比用什么规则

客户端会做简单的 `x.y.z` 数字对比（semver 的简化版）。建议你的服务端也遵循同样的三段数字版本。

